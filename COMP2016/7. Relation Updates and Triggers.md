- Table creation
	- defining the schema
	- formulating constraints

- Null values
	- situations
		- unknown
		- inapplicable
	- issues
		- IS / IS NOT NULL
		- is a condition true or false for a NULL
	- 3-valued logic
		- true
		- false
		- unknown
	- WHERE clause eliminates tuples not true
		- discards tuples with false and NULL values
	- NULL values are not counted by COUNT
	- SUM, AVG, MAX and MIN discard NULL values
	- Two tuples are duplicates if corresponding attributes both contain NULL

- Checking arbitrary constraints
	- CHECK(gpa > 0)

- Insertion
	- INSERT INTO DEPOSIT
		VALUES('A1', 1, 20000)
	- INSERT INTO DEPOSIT 
		SELECT acc-id, cust-id, 50 
		FROM DEPOSIT 
		WHERE cust-id = 2
	- INSERT ALL 
		INTO T1
		(col 1, col 2) VALUES (v1, v2)
		INTO T2
		(col 1, col 2) VALUES (v1, v2)
		SELECT * FROM DUAL
- Delete tuples
	- DELETE FROM ACC 
		WHERE balance = 
				(SELECT MAX(balance) 
				FROM ACC)
- Update
	- UPDATE ACC 
		SET balance = balance * 1.05 
		WHERE balance > 10000

- Triggers
	- a procedure automatically executed by the database, whenever a certain table is modified
	- CREATE OR REPLACE TRIGGER STU_score_constraint 
		BEFORE INSERT OR UPDATE ON STU
		FOR EACH ROW
		BEGIN
			IF (:new.score < 0 OR :new.score > 100) THEN 
				RAISE_APPLICATION_ERROR(-20000, ‘Invalid score’); 
			END IF; 
		END;
	- CREATE OR REPLACE TRIGGER FIRST_CLASS_score 
		BEFORE INSERT OR UPDATE ON FIRST-CLASS FOR EACH ROW 
		DECLARE 
			a INTEGER;
		BEGIN 
			SELECT AVG(score) INTO a FROM TRAN 
				WHERE stu-id = :new.stu-id; 
			IF (a < 85) THEN 
				RAISE_APPLICATION_ERROR(-20000, ‘Too low average’); 
			END IF; 
		END
	- CREATE OR REPLACE TRIGGER STU_stat_insert
		AFTER INSERT ON STU 
		FOR EACH ROW 
		DECLARE 
			c INTEGER; 
		BEGIN 
			SELECT COUNT( * ) into c FROM DEPT-CNT 
				WHERE dept-id = :new.dept-id; 
			IF (c = 0) THEN 
				INSERT INTO DEPT-CNT VALUES(:new.dept-id, 1); 
			ELSE 
				UPDATE DEPT-CNT SET stu-cnt = stu-cnt + 1 WHERE dept-id = :new.dept-id; 
			END IF;
		END;
	- CREATE OR REPLACE TRIGGER STU_stat_delete 
		AFTER DELETE ON STU 
		FOR EACH ROW 
		DECLARE 
			c INTEGER; 
		BEGIN 
			SELECT stu-cnt into c FROM DEPT-CNT 
				WHERE dept-id = :old.dept-id; 
			IF (c = 1) THEN 
				DELETE FROM DEPT-CNT
				WHERE dept-id = :old.dept-id; 
			ELSE 
				UPDATE DEPT-CNT SET stu-cnt = stu-cnt - 1 
				WHERE dept-id = :old.dept-id;
			END IF; 
		END;

## **Tutorial**
![[COMP2016/7.png/Tutorial 1.png]]
```sql
CREATE TABLE Students  
	(sid CHAR(8), sname 
	CHAR(20),  
	major CHAR(10), 
	year_of_study INTEGER, 
	gpa REAL,  
	PRIMARY KEY (sid),  
	CHECK (gpa >= 0 AND gpa <= 4));


CREATE TABLE Courses  
	(cid CHAR(8), 
	cname CHAR(20), 
	enroll_count INTEGER,  
	lecturer CHAR(20),  
	PRIMARY KEY (cid));


CREATE TABLE Enrolled  
	(sid CHAR(8),
	cid CHAR(8),  
	score REAL,  
	PRIMARY KEY (sid, cid),  
	FOREIGN KEY (sid) REFERENCES Students  
		ON DELETE CASCADE,  
	FOREIGN KEY (cid) REFERENCES Courses  
	CHECK (score IS NULL OR (score >= 0 AND score <= 100)
```
![[COMP2016/7.png/Tutorial 2.png]]
```sql
INSERT INTO Enrolled 
	SELECT sid, 'COMP1160', NULL FROM Students
	WHERE (major = 'CS' OR major = 'is') AND year_of_study = 1


DELET FROM Courses
	WHERE (cid IN (SELECT cid
				FROM Enrolled
				GROUP BY cid
				HAVING count(*) < 5));


UPDATE Students 
	SET gpa = gpa + gpa * 0.1
	WHERE sid IN (SELECT sid FROM Enrolled 
				WHERE cid = 'COMP1160')
```
![[COMP2016/7.png/Tutorial 3.png]]
```sql
CREATE OR REPLACE TRIGGER Increase_Enrollment_Count
AFTER INSERT OR UPDATE ON Enrolled
FOR EACH ROW
DECLARE
	cnt INTEGER;
BEGIN
	SELECT enroll_count INTO cnt FROM Courses
	WHERE cid = :new.cid;
	cnt := cnt + 1;
	UPDATE Courses
		SET enroll_count = cnt
		WHERE cid = :new.cid;
END;
```
![[COMP2016/7.png/Tutorial 4.png]]
```sql
CREATE OR REPLACE TRIGGER Decrease_Enrollment_Count
AFTER DELETE OR UPDATE ON Enrolled
FOR EACH ROW
DECLARE
	cnt INTEGER;
BEGIN
	SELECT enroll_count INTO cnt FROM Courses
	WHERE cid = :old.cid;
	cnt := cnt - 1;
	UPDATE Courses
		SET enroll_count = cnt
		WHERE cid = :old.cid;
END;
```