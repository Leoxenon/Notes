- Redundancy
	- Negative impacts
		- Higher space consumption
		- Higher update overhead
		- Insertion/update anomaly
	- Reason
		- an attribute determines other attributes
		- once it is know, attributes it determines is also decided
			- functional dependence(FD)

- Decomposition
	- decompose table with redundance into two tables
	- Lossless Join
		- the decomposed tables must be able to reproduce the original table
	- Legitimacy of decomposition
		- The new tables must have common attributes
		- The common attributes must be the candidate key of at least one new table 

- Functional dependency (FD)
	- L and R are two sets of attributes
	- L -> R means
		- if we know a tuple's L, there is only a single possibility for the tuple's R
	- trivial FD
		- the attribute determines itself
	- if there is a FD whose left hand side is not a candidate key
		- the table has redundancy
	- Dependency Properties
		- A candidate key determines all
		- super key determines all
		- Inference rules for FDs
			- Given a set of FDs F, we can infer additional FDs that hold whenever the FDs in F hold
				- id -> rating 
				- rating -> hourly-wages
					- id -> hourly-wages
			- Reflexivity
				- If Y âŠ† X, then X -> Y
				- trivial FD's
			- Union
				- If X -> Y and X -> Z, then X -> YZ
				- cust-id -> cust-name
				- cust-id -> cust-city
					- cust-id -> (cust-name, cust-city)
			- Transitivity
				- If X -> Y and Y -> Z, then X -> Z
				- creditcard-no -> cust-id
				- cust-id -> cust-name
					- creditcard-no -> cust-name
			- Augmentation
				- If X -> Y, then XZ -> YZ, for every Z
				- creditcard-no -> cust-id
					- (creditcard-no, branch-id) -> (cust-id, branch-id)
			- Derived Rules
				- Decomposition (Splitting) Rule
					- If X -> YZ, then X -> Y and X -> Z
				- Pseudo-transitivity Rule 
					- If X -> Y and WY -> Z, then XW -> Z
		- Prove FDs
			![[Prove FDs.png]]
		- Disprove FDs
			- Find a counter example
		- Closure Test
			- $Y^+$
				- closure of Y
			- Basic step
				- $Y^+ = Y$
			- Induction
				- Look for an FD's left side X that is a subset of the current $Y^+$ 
				- if the FD is X -> A, add A to $Y^+$ 
			- can be used to prove or disprove

## **Tutorial**

![[COMP2016/8.png/Tutorial 1.png]]

![[Solution 1.png]]
 ![[COMP2016/8.png/Tutorial 2.png]]
 ***Answer: 3***
 ![[COMP2016/8.png/Tutorial 3.png]]
***Answer:***
 theater -> city
 (title, city) -> theater

 legal
	 common attribute theater
	 theater is a candidate key in (theater, city)

![[COMP2016/8.png/Tutorial 4.png]]
```sql
SELECT * 
FROM Table T1
WHERE EXISTS (SELECT T2 FROM Table T2
				WHERE T2.A = T1.A AND T2.B <> T1.B)
```
```sql
SELECT * 
FROM Table T1, Table T2
WHERE T1.A = T2.A AND T1.B <> T2.B
```
```sql
SELECT *
FROM Table
GROUP BY A
HAVING COUNT(DISTINCT B) > 1
```

![[COMP2016/8.png/Tutorial 5.png]]
$AB^+ = AB$
$AB^+ += C$
$AB^+ += DE$
$AB^+ += F$
$AB^+ += GH$
$AB^+ += IJ$
$AB^+ = ABCDEFGHIJ$

![[COMP2016/8.png/Tutorial 6.png]]
1. $BFG^+ = BFG$
	$BFG^+ = BFGEH$
	can not derive $BFG \to AE$
2. $ACG^+ = ACG$
	$ACG^+ = ACGBEH$
	can not derive $ACG \to DH$
3. $CEG^+ = CEG$
	$CEG^+ = CEGHAB$
	can derive $CEG^+ \to AB$

![[COMP2016/8.png/Tutorial 7.png]]
1. $BDF^+ = BDF$
	$BDF^+ = BDF$
	not a key
2. $ACDF^+ = ACDF$
	$ACDF^+ = ACDFEG$
	not a key
3. $ABDFG^+ = ABDFG$
	$ABDFG^+ = ABDFGCE$
	$ABDF^+= ABDF$
	$ABDF^+ = ABDFCEG$
	not a key
4. $BDFG^+ = BDFG$
	$BDFG^+= BDFGECA$

![[COMP2016/8.png/Tutorial 8.png]]
- Subsets
	- $AB^+ = ABCD$
	- $BC^+ = BCDA$
	- $CD^+ = CDAB$
	- $AD^+ = ADBC$
(a) candidates keys: AB, BC, CD, AD
(b) superkeys: ABC, ABD, ACD, BCD, ABCD


- Tricks for finding the key
	- if an attribute never appears on the RHS of any FD
		- it must be part of the key
	- if an attribute never appears on the LHS of any FD, but appears on the RHS of any FD
		- it must not be part of any key