# Trees
- Tree
	- represents hierarchical relationship
	- node
		- represents object
		- root
			- starting node
		- parent
			- root has no parent
		- child
			- leaves have no child
		- siblings
			- have the same parent
		- leaves
			- without any children
	- edge
		- represents relationship
		- A tree with N nodes has N-1 edges
	- path
		- a sequence of nodes, n1, n2, ..., nk
		- length
			- number of edges on the path, k-1
	- depth
		- the length of the unique path from root to the node
		- the depth of a tree is equal to the depth of the deepest leaf
	- height
		- the length of the longest path from the node to a leaf
		- the height of a tree is equal to the height of the root
	- subtree
		- any node together with all its descendants
	- representation
		- FirstChild pointer
			- point to next level
		- NextSibling pointer
			- point to same level

- Binary tree
	- each nodes can have at most two children
		- leftchild
		- rightchild
	- Strictly Binary Tree
		- each nonleaf node has non-empty left and right subtrees
	- Complete (Full) Binary Tree
		- strictly binary tree with all leaf nodes at level of the depth d
		- has $$2^0 + 2^1 + ... + 2^d = 2^{d+1} - 1$$ nodes
		- has depth O(log N) $$∵2^{d+1} - 1 = N ∴d = log(N + 1) - 1$$
		- For simple binary tree: 
			.$$∵N <= 2^{d+1}-1$$ 
			.$$∴2^{d+1} >= N+1$$ 
			.$$∴d >= log(N+1)-1$$
	- Linked structure
		- Each node = data cells + two child pointers
	- Tree Traversal
		- PreOrder traversal strategy
			- depth-first
			- cur-left-right
			- can obtain prefix expression
		- InOrder traversal strategy
			- left-cur-right
			- can obtain infix expression
		- PostOrder traversal strategy
			- depth-first
			- right-left-cur
			- can obtain postfix expression

- Expression Tree
	- Leaves
		- operands
	- other nodes
		- operators
	- Constructing Expression Tree
		- Convert postfix expression into expression tree
			- if operand, create a one-node tree
			- if operator, form a new tree whose root is the operator

- Binary Search Trees (BST)
	- key.left < key.parent < key.right
		- The key value of a node is always greater than the keys of the nodes in its left subtree
		- The key value of a node is always smaller than the keys of the nodes in its right subtree
	- InOrder traversal
		- the keys appear in sorted order
	- Search for a key
		- O(d)
		- O(logN) for complete binary search trees
	- Find minimum/maximum
		- O(d)
	- Insert an element
		- determine the location by searching
		- insert the element at the position
	- Delete an element
		- leaf
			simply delete
		- interior with only one subtree
			- replace the node with its child
		- interior with two subtrees 
			- replace the key of the node by the minimum/maximum of right/left subtree
			- delete the minimum/maximum element

- Adelson-Velskii and Landis Tree (AVL Tree)
	- is BST tree
	- maintains a balanced binary search tree
	- aims to keep the height at O(logN) instead of possible O(N)
	- In an AVL tree
		- for every nodes, the heights of left and right subtrees differ by at most 1
		- height information is kept for each node
		- the height is at most 1.44log(N+2)-0.328
		- the minimum number of nodes
			$S(h) = S(h-1) + S(h-2) + 1$
			- The minimum number of nodes grows exponentially in h
			- Therefore, the height grows logarithmically in number of nodes 
	- Insert a node
		- if inserting at the deeper subtree, it will cause imbalance
			- on the path to the root, idenify the first (nearest) affected node
				- LL case: Insertion in the left subtree of the left child
				- RR case: Insertion in the right subtree of the right child
				- LR case: Insertion in the right subtree of the left child
				- RL case: Insertion in the left subtree of the right child
		- restore the balance
			- single rotation
				- for LL & RR cases
				![[Single Right Rotation to fix LL case.png]]
				![[Single Left Rotation to fix RR case.png]]
			- double rotation
				- for LR & RL cases
				![[double rotation.png]]
				![[Left-right double rotation to fix the LR case.png]]
				![[Right-left double rotation to fix the RL case.png]]
		- Worst-case complexity of insertion: O(logN)
			- Tree starts balanced
			- A rotation is O(1)
			- Tree ends balanced
	- Delete a node
		- search for imbalanced nodes all the way to the root
		- single rotation or double rotation
		- Worst-case complexity of deletion: O(logN)


![[COMP2015/3.png/Tutorial 1.png]]
C
![[COMP2015/3.png/Tutorial 2.png]]
node 18 gets imbalanced, LL case
![[COMP2015/3.png/Tutorial 3.png]]

node 13 gets imbalanced, RL case

![[COMP2015/3.png/Tutorial 4.png]]

![[COMP2015/3.png/Tutorial 5.png]]

![[COMP2015/3.png/Tutorial 6.png]]


- Splay Tree
	- After a node is accessed, it is pushed to the root by a series of AVL tree rotations
	- do not require the maintenance of height or balance information
	- Splaying a Node
		- x is a child of root of tree
			- Zig
		- node and parent are at same side
			- Zig-Zig
		- node and parent are at different sides
			- Zig-Zag

![[COMP2015/3.png/Tutorial 7.png]]

![[COMP2015/3.png/Tutorial 8.png]]


- B-Trees
	- All data are stored at the leaves
	- All leaves are at the same depth
	- B-tree of order M
		- root is a leaf or has 2 to M children
		- nonleaf nodes have M/2 to M children
	- B+ tree
		- leaf nodes are connected as a Linked List
	- Insert
		- leaf node is not full
			- fill in empty slot
		- leaf node is full
			- split leaf node and adjust parents up to root node
	- Delete
		- may have to combine leaf nodes and adjust parents up to root node

![[COMP2015/3.png/Tutorial 9.png]]
![[Tutorial 9.1.png]]
![[Tutorial 9.2.png]]
![[Tutorial 9.3.png]]
![[Tutorial 9.4.png]]
![[Tutorial 9.5.png]]
![[Tutorial 9.6.png]]
![[Tutorial 9.7.png]]

![[COMP2015/3.png/Tutorial 10.png]]

![[COMP2015/3.png/Tutorial 11.png]]


![[COMP2015/3.png/Tutorial 12.png]]

![[COMP2015/3.png/Tutorial 13.png]]
(a) O(N)
(b) O(N)
(c) O(logN)
(d) O(1)
(e) O(N)