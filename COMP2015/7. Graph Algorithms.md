# Graph Algorithms
- Graphs
	- Multiple relationship connections
	- Relationships dictate structure
	- Connection freedom
	- Both elements and connections can store data
	- Graphs represent the relationships among data items
	- A graph G consists of
		- a set V of vertices
			- { a, b, c, d, e, f, g, h, i, j, k, l }
			- |V|: Number of vertices
		- a set E of edges
			- { (a, b), (a, e), (b, e), (b, f), (c, j), (c, g), (c, h), (d, h), (e, j) }
			- each edge connects two vertices
			- |E|: Number of edges
		- vertex u and v are adjacent if $(u, v) ∈ E$
	- Directed Graph (Digraph)
		- each edge has a direction
	- Degrees
		- the number of edges incident to it
		- out-degree
			- the number of arcs leaving the vertex
		- in-degree
			- the number of arcs entering the vertex
	- Path
		- a sequence of vertices connected by edges
		- Simple path
			- all vertices in the path are distinct, except the first and the last
		- Cycle
			- a path the begins and ends at the same vertex
			- Simple cycle
				- all vertices in the cycle are distinct, except the first and the last
	- Connected Graph
		- there exists a path between every pair of distinct vertices
		- Connectivity
			- strongly connected
				- there is a path from each vertex to every other vertex in a directed graph.
			- weakly connected
				- at least 2 vertices are not connected in a directed graph
	- Complete Graph
		- each pair of distinct vertices has an edge

- Graph Representation
	- store two sets
		- Vertices
		- Edges
	- Adjacency matrix
		- use a 1D array to store the vertices
		- use two-dimensional array to store the edges
		- number of vertices must be known in advance
		- space requirement
			- $\Theta(|V|^2)$
			- not efficient for sparse graph
		- access a edge in $O(1)$ time
	- Adjacency list
		- n linked lists, where n is the number of vertices
		- For each vertex, keep a list of all adjacent vertices
			- for digraphs, stores only the out-edges
		- space requirement is $O(|E| + |V|)$
			- if sparse graph, requires less space
		- find all nodes adjacent to a given node j efficiently

- **Traversal**
	- Pick any vertex to start
		- mark it as "visited"
	- Put all neighbors in a "to be visited" collection
	- Move onto the next vertex in the collection
		- mark it as "visited"
	- Put all unvisited neighbors in "to be visited"
	- Move onto the next vertex in the collection
	- ...
	- All the vertex in "to be visited" are visited
- **Breadth First Search**
	- Using queue
```cpp
bfs(graph) {
	toVisit.enqueue(first vertex) 
	while(!toVisit.isEmpty()) {
		current = toVisit.dequeue() 
		for (v : current.neighbors()) 
			if (!v.visited) 
				toVisit.enqueue(v) 
		visited.add(current)
	}
}
```
- **Depth First Search**
	- Using stack
```cpp
dfs(graph) {
	toVisit.push(first vertex) 
	while(!toVisit.isEmpty()) {
		current = toVisit.pop() 
		for (V : current.neighbors()) 
			if (!toVisit.contains(V)) 
				toVisit.push(v) 
		visited.add(current)
	}
}
```

![[COMP2015/7.png/Tutorial 1.png]]
(i)
Queue: C D G B A F 
Visited: E C D G B A F
(ii)
Stack: F C A D E G 
Visited: B A D E G C F

- **Shortest Path Algorithm**
	- minimizes total cost of the path
	- **Single-Source Shortest Path Algorithms**
		- **Dijkstra’s algorithm**
			- Does not allow negative edges
			- Undirected/directed graphs
			- **Greedy Algorithm**
				- Always choose the vertex with the smallest distance
		- **Bellman-Ford’s algorithm**
			- Work correctly for any graph 
			- Must be directed graphs if negative edges are included
			- **Dynamic Programming Algorithm**
				- distance to each vertex is stored in each vertex
				- for each edge, try to test and update the distance to v
			- Negative Cycle Detection
				- one more iteration
				- if distance to at least one vertex can be improved
					- there exists negative cycle
```cpp
boolean Bellman-Ford (G, w, s) {
	// Initialization
	for (each vertex v) {
		d[v] ← infinity 
		p[v] ← Null 
		d[s] ← 0 
	}
		
	// Update distance
	for(i = 1 to |V|-1) { 
		for (each edge e = (u, v)) {
			if (d[v] > d[u] + w[u, v]) { 
				d[v] ← d[u] + w[u, v]
				p[v] ← u 
			}
		}
	}
		
	// Negative cycle check
	for each edge e = (u, v) 
		if d[v] > d[u] + w[u, v] 
			return FALSE 
	return TRUE
}
```

- Topological Sort
	- for a directed acyclic graph 
		- a directed graph without cycles
	- Arranging all nodes in the graph in a topological order
		- if there is a path from $v_i$ to $v_j$, the $v_j$ appears after $v_i$
		- not possible if there is a cycle
```cpp
int[] TopoSort(int[] aList) {
	n = |V|; 
	for i = 1 to n { 
		select a node v that has no successor; 
		aList.add(1, v); 
		delete node v and its edges from the graph; 
	} 
	return aList;
}
```

![[COMP2015/7.png/Tutorial 2.png]]
Stack: 9 8 5 3 7 4 2 6 1 0
res = {0, 1, 6, 2, 4, 7, 3, 5, 8, 9}

- Minimum Spanning Tree (MST)
	- select edges in a connected and undirected graph
		- form a tree that connects all vertices
		- minimize the total edge weight of the spanning tree
	- tree structure
		- acyclic
	- spanning
		- covers every vertex
	- minimum
		- at lowest total cost
	- **Prim's Algorithm**
		- Grow the tree in successive stages
		- At each stage, a new vertex u is found to add to the tree by choosing the edge (v, u) such that the cost of (v, u) is the minimum where v is in the tree
		- Identical to Dijkstra's algorithm for shortest paths
	- A minimum spanning tree should have the number of edges equals to |V| - 1

![[COMP2015/7.png/Tutorial 3.png]]
starting from g:
g
d
e
b
b(c, a)
a(f)

starting from a:
a
f, b
b(c, e)
e(d)
d(g) 

starting from c:
c
b
a, e
a(f), e(d)
d(g)

Minimum Spanning Tree of a graph is unique
