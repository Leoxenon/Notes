# Hash Tables
- Objective
	- performing insertion, deletion, finding in constant time
	- without sorting the data

- Hash Table
	- a symbol table using a hash function is called a hash table
	- is a fixed size (TableSize) array containing keys
	- each table is mapped into some number from 0 to TableSize - 1
	- symbol table
		- dictionary
		- a collection of <key, value> pairs
			- key and value can be anything
			- value can be composed of multiple parts
	- hash function
		- maps a search key to an integer index
		- requirements
			- should be simple to compute
			- should ensure that any two distinct keys get different cells
			- should distribute the keys evenly amoung the cells
	- Applications
		- Compilers use hash tables (symbol tables) to keep track of declared variables
		- On-line spelling checkers: after prehashing the entire dictionary, one can check each word in constant time and print out the misspelled word in order of their appearance in the document.

- Hash Function
	- Hashing basic plan
		- create an array for the items to be stored
		- use a hash function to figure out storage location from key
		- a collision resolution scheme is necessary
	![[Hash Function.png]]
		Usually, m << N
		h(Ki) = an integer in [0, m-1], the hash value of Ki
	- The division method for numeric keys
		- h(k) = k mod m
			- m is the table size and a prime number
	- Non-numeric keys are converted to numbers
		- Method 1
			- add up the ASCII values of the characters in the string
				- different permutations of the same set of characters would have the same hash value
				- If the table size is large, the keys are not distributed well
		- Method 2
			- Represent the first three characters s1s2s3 in the string by the ASCII code, choose a number r
			- $ASCII(s1) + ASCII(s2)r + ASCII(s3)r^2$
	- Collision Handling
		- collision
			- two or more keys hash to same index
		- Seperate Chaining
			- keep a linked list of keys that hash to the same value
				- memory allocation in linked list manipulation will slow down the program
		- Open Addressing
			- relocate the key K to be inserted if it collides with an existing key
			- hi(K) = (hash(K) + f(i)) mod m, with f(0) = 0
			- f: collision resolution strategy
				- Linear Probing
					- $f(i) = i$
					- cells are probed sequentially (with wraparound)
					- Primary Clustering
						- linear probing tends to create long sequences of filled cells in a hash table
						- degrades the performance of hash table
				- Quadratic Probing
					- $f(i) = i^2$
					- two keys with different home positions will have different probe sequences
					- If the table size is prime
						- a new key can always be inserted if the table is at least half empty
					- If the table size is a prime of the form 4k+3
						- the entire table can be probed
					- Secondary Clustering
						- Keys that hash to the same home position will probe the same alternative cells
				- Double Hashing
					- $f(i) = i * hash_{2}(K)$
						- has2(K) = R - (K mod R)
						- R is a prime number smaller than m
						- hash2(K) should return a nonzero integer
		- Rehashing
			- Build another table, twice as big (and prime)
			- The hash function has to be changed
			- All entries in the hash table have to be re-entered using the new hash function
			- is rarely necessary for most applications


![[COMP2015/4.png/Tutorial 1.png]]

![[Tutorial  2.png]]


