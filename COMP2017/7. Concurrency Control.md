- process
	- any basic unit of execution

- Concurrency control problems
	- inter-dependent process
		- share data
		- must be executed in certain order
	- execute concurrently

- Concurrent Access to Shared Data
	- sequentially
		- correct
	- concurrently
		- incorrect
- Synchronization
	- follow a given execution order

## Concurrency control methods

- Atomic Instruction
	- Once an atomic instruction is executed, it is executed to completion without interruption
	- If two processes execute the same atomic instruction on two respective processors, the execution is sequential
- Critical Section
	- is the code segment to access the shared data
	- only one process can execute its critical section at a time
	- Solution
		- Test-and-Set
			- a hardware atomic instruction
			- manage the lock
			- if the lock is not lock
				- lock the lock and return false
			- else
				- return true
		- Semaphore (S)
			- an integer variable
			- can only be accessed by two atomic operations
				- wait(S)
					- while (S<=0);
					- S = S - 1;
				- signal(S)
					- S = S + 1;
			- only one process can modify S at the same time
- Process Synchronization
	- initially gives the key to first executed process
	- initially set S to 0, first executed process no need to wait
- Resource Sharing
	- initially set S to the number of units of resources
- Producer-Consumer Problem
	- producer process
		- produces data and writes it to a buffer
	- consumer process
		- reads & removes this data from the shared buffer and consumes it
	- Problem
		- If a shared buffer can store N data items, how can a producer transifer more than N data items to a consumer
	- Solution
		- Mutual exclusion
			- at most one process could access the shared buffer at a time
			- Semaphore: mutex
				- initially set to 1
		- Control writing
			- When the buffer has empty space, the producer could write a data item to the buffer
			- Semaphore: empty
				- count the number of empty buffer spaces
		- Control reading
			- When the buffer has data, the consumer could read a data itemfrom the buffer and then free the corresponding buffer space
			- Semaphore: occupied
				- count the number of occupied buffer spaces

## Tutorial
![[COMP2017/7.png/Tutorial 1.png]]
(a) To ensure that the account balance is correctly maintained
(b) Let LockX be boolean with initial value false
	while (TestAndSet(LockX));
	X = X + 1000;
	LockX = false;
(c) Let Sx be a binary semaphore for account X (initial value = 1)
	wait(Sx);
	X = X + 1000;
	signal(Sx);

![[COMP2017/7.png/Tutorial 2.png]]
Let Sx and Sy be binary semaphores for accounts X and Y respectively (initial value = 1)
	wait(Sx);
	wait(Sy);
	X = X - 1000;
	Y = Y + 1000;
	signal(Sx);
	signal(Sy);

![[COMP2017/7.png/Tutorial 3.png]]
Let S1, S2 be semaphore with initial value 0
Process A
	X1();
	signal(S1);
Process B
	wait(S1);
	X2();
	signal(S2);
Process C
	wait(S2);
	X3();

![[COMP2017/7.png/Tutorial 4.png]]

Let S1, S2 be semaphores (initial value = 0)
Process A
	Y1();
	signal(S1);
	signal(S1);
Process B
	wait(S1);
	Y2();
	signal(S2)
Process C
	wait(S1);
	Y3();
	signal(S2)
Process D
	wait(S2);
	wait(S2);
	Y4();

![[COMP2017/7.png/Tutorial 5.png]]
Semaphore can only be accessed by two atomic operations

![[COMP2017/7.png/Tutorial 6.png]]
Changing order of wait()
	The producer will wait in the buffer indefinitely
Changing order of signal() is ok

![[COMP2017/7.png/Tutorial 7.png]]

- Process 1 has locked account A
	Then it is suspended by OS
- Process 2 has locked account B
	Then it is suspended by OS
- Process 1 can not lock account B
- Process 2 can not lock account A
